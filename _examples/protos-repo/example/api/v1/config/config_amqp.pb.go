// Code generated by protoc-gen-go-amqp. DO NOT EDIT.
// versions:
// - protoc-gen-go-amqp v1.0.0
// - protoc             v5.27.0
// source: protos-repo/example/api/v1/config.proto

// Package naming convention: api.{version}.{app}.{module}

package config

import (
	context "context"
	bootstrap "github.com/asjard/asjard/core/bootstrap"
	server "github.com/asjard/asjard/core/server"
	xamqp1 "github.com/asjard/asjard/pkg/server/xamqp"
	xamqp "github.com/asjard/asjard/pkg/stores/xamqp"
	amqp "github.com/streadway/amqp"
	proto "google.golang.org/protobuf/proto"
	common "protos-repo/common/common"
	sync "sync"
)

type ConfigAmqpClientOptions struct {
	clientName string
}
type ConfigAmqpClientOption func(opts *ConfigAmqpClientOptions)

func ConfigAmqpClientWithClient(clientName string) ConfigAmqpClientOption {
	return func(opts *ConfigAmqpClientOptions) {
		if clientName != "" {
			opts.clientName = clientName
		}
	}
}

type ConfigAmqpClient struct {
	*xamqp.ClientConn
	options *ConfigAmqpClientOptions
}

var (
	configAmqpClient     *ConfigAmqpClient
	configAmqpClientOnce sync.Once
)

func NewConfigAmqpClient(opts ...ConfigAmqpClientOption) *ConfigAmqpClient {
	configAmqpClientOnce.Do(func() {
		options := &ConfigAmqpClientOptions{
			clientName: "default",
		}
		for _, opt := range opts {
			opt(options)
		}
		configAmqpClient = &ConfigAmqpClient{
			options: options,
		}
		bootstrap.AddBootstrap(configAmqpClient)
	})
	return configAmqpClient
}
func (c *ConfigAmqpClient) Start() error {
	conn, err := xamqp.Client(xamqp.WithClientName(c.options.clientName))
	if err != nil {
		return err
	}
	c.ClientConn = conn
	ch, err := conn.Channel()
	if err != nil {
		return err
	}
	defer ch.Close()
	for _, method := range ConfigAmqpServiceDesc.Methods {
		if method.Queue != "" {
			if _, err := ch.QueueDeclare(method.Queue, method.Durable, method.AutoDelete, method.Exclusive, method.NoWait, method.Table); err != nil {
				return err
			}
		}
		if method.Exchange != "" {
			if err := ch.ExchangeDeclare(method.Exchange, method.Kind, method.Durable, method.AutoDelete, method.Internal, method.NoWait, method.Table); err != nil {
				return err
			}
			if method.Queue != "" {
				if err := ch.QueueBind(method.Queue, method.Route, method.Exchange, method.NoWait, method.Table); err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (c *ConfigAmqpClient) Stop() {}
func (c *ConfigAmqpClient) GetChannel() (*amqp.Channel, error) {
	return c.ClientConn.Channel()
}

// Simple Get: Retrieves the current configuration.
// Asjard generates both a gRPC method and a REST endpoint.
func (c *ConfigAmqpClient) Get(ctx context.Context, in *ConfigGetReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// GetAndDecrypt: Retrieves an encrypted configuration and returns it in plain text.
// Demonstrates handling specialized business logic through the same framework.
func (c *ConfigAmqpClient) GetAndDecrypt(ctx context.Context, in *common.Empty, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Simple Get: Retrieves the current configuration.
// Asjard generates both a gRPC method and a REST endpoint.
func _Config_Get_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(ConfigGetReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).Get(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: Config_Get_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(ConfigServer).Get(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// GetAndDecrypt: Retrieves an encrypted configuration and returns it in plain text.
// Demonstrates handling specialized business logic through the same framework.
func _Config_GetAndDecrypt_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(common.Empty)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigServer).GetAndDecrypt(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: Config_GetAndDecrypt_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(ConfigServer).GetAndDecrypt(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigAmqpServiceDesc is the xamqp1.ServiceDesc for Config service.
// It's only intended for direct use with xamqp1.AddHandler,
// and not to be introspected or modified (even as a copy)
//
// Config service handles application configuration retrieval and management.
var ConfigAmqpServiceDesc = xamqp1.ServiceDesc{
	ServiceName: "api.v1.example.docs.Config",
	HandlerType: (*ConfigServer)(nil),
	Methods:     []xamqp1.MethodDesc{},
}
