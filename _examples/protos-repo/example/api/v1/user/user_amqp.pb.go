// Code generated by protoc-gen-go-amqp. DO NOT EDIT.
// versions:
// - protoc-gen-go-amqp v1.0.0
// - protoc             v5.27.0
// source: protos-repo/example/api/v1/user.proto

package user

import (
	context "context"
	bootstrap "github.com/asjard/asjard/core/bootstrap"
	server "github.com/asjard/asjard/core/server"
	xamqp1 "github.com/asjard/asjard/pkg/server/xamqp"
	xamqp "github.com/asjard/asjard/pkg/stores/xamqp"
	amqp "github.com/streadway/amqp"
	proto "google.golang.org/protobuf/proto"
	common "protos-repo/common/common"
	sync "sync"
)

type UserAmqpClientOptions struct {
	clientName string
}
type UserAmqpClientOption func(opts *UserAmqpClientOptions)

func UserAmqpClientWithClient(clientName string) UserAmqpClientOption {
	return func(opts *UserAmqpClientOptions) {
		if clientName != "" {
			opts.clientName = clientName
		}
	}
}

type UserAmqpClient struct {
	*xamqp.ClientConn
	options *UserAmqpClientOptions
}

var (
	userAmqpClient     *UserAmqpClient
	userAmqpClientOnce sync.Once
)

func NewUserAmqpClient(opts ...UserAmqpClientOption) *UserAmqpClient {
	userAmqpClientOnce.Do(func() {
		options := &UserAmqpClientOptions{
			clientName: "default",
		}
		for _, opt := range opts {
			opt(options)
		}
		userAmqpClient = &UserAmqpClient{
			options: options,
		}
		bootstrap.AddBootstrap(userAmqpClient)
	})
	return userAmqpClient
}
func (c *UserAmqpClient) Start() error {
	conn, err := xamqp.Client(xamqp.WithClientName(c.options.clientName))
	if err != nil {
		return err
	}
	c.ClientConn = conn
	ch, err := conn.Channel()
	if err != nil {
		return err
	}
	defer ch.Close()
	for _, method := range UserAmqpServiceDesc.Methods {
		if method.Queue != "" {
			if _, err := ch.QueueDeclare(method.Queue, method.Durable, method.AutoDelete, method.Exclusive, method.NoWait, method.Table); err != nil {
				return err
			}
		}
		if method.Exchange != "" {
			if err := ch.ExchangeDeclare(method.Exchange, method.Kind, method.Durable, method.AutoDelete, method.Internal, method.NoWait, method.Table); err != nil {
				return err
			}
			if method.Queue != "" {
				if err := ch.QueueBind(method.Queue, method.Route, method.Exchange, method.NoWait, method.Table); err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (c *UserAmqpClient) Stop() {}
func (c *UserAmqpClient) GetChannel() (*amqp.Channel, error) {
	return c.ClientConn.Channel()
}

// Create persists a new user record.
// In Asjard, this method typically uses 'SetData' to pre-allocate IDs
// and initialize the cache state to prevent early cache-miss storms.
func (c *UserAmqpClient) Create(ctx context.Context, in *UserReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Get retrieves a single user by their primary identifier (username/key).
// Workflow: LocalCache -> Redis -> Database.
// Failure to find a record results in a gRPC NOT_FOUND (HTTP 404).
func (c *UserAmqpClient) Get(ctx context.Context, in *common.ReqWithName, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Update modifies an existing user profile.
// Triggers the 'Delayed Double Delete' strategy via Asjard's Time Wheel
// to ensure consistency across distributed LocalCache nodes.
func (c *UserAmqpClient) Update(ctx context.Context, in *UserReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Del removes the user record from the persistent store and
// synchronously purges associated entries from all cache levels.
func (c *UserAmqpClient) Del(ctx context.Context, in *common.ReqWithName, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Search filters users with pagination support.
// Note: Search results are typically cached at the 'Group' level
// with shorter TTLs compared to individual 'Get' records.
func (c *UserAmqpClient) Search(ctx context.Context, in *UserSearchReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// User add a credit card
// Add a credit card and update user's card count
// This implementation demonstrates how to use xgorm.WithDB(ctx, tx) to maintain
// transactional integrity across multiple table updates.
func (c *UserAmqpClient) AddCreditCard(ctx context.Context, in *UserCreditCardReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// User remove a credit card
func (c *UserAmqpClient) RemoveCreditCard(ctx context.Context, in *UserCreditCardReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Get user specify credit card info
func (c *UserAmqpClient) GetCreditCard(ctx context.Context, in *UserCreditCardReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Get all credit cards under user
func (c *UserAmqpClient) SearchCreditCard(ctx context.Context, in *common.ReqWithName, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// Create persists a new user record.
// In Asjard, this method typically uses 'SetData' to pre-allocate IDs
// and initialize the cache state to prevent early cache-miss storms.
func _User_Create_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(UserReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Create(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Create_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).Create(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// Get retrieves a single user by their primary identifier (username/key).
// Workflow: LocalCache -> Redis -> Database.
// Failure to find a record results in a gRPC NOT_FOUND (HTTP 404).
func _User_Get_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(common.ReqWithName)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Get(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Get_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).Get(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// Update modifies an existing user profile.
// Triggers the 'Delayed Double Delete' strategy via Asjard's Time Wheel
// to ensure consistency across distributed LocalCache nodes.
func _User_Update_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(UserReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Update(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Update_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).Update(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// Del removes the user record from the persistent store and
// synchronously purges associated entries from all cache levels.
func _User_Del_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(common.ReqWithName)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Del(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Del_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).Del(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// Search filters users with pagination support.
// Note: Search results are typically cached at the 'Group' level
// with shorter TTLs compared to individual 'Get' records.
func _User_Search_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(UserSearchReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Search(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Search_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).Search(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// User add a credit card
// Add a credit card and update user's card count
// This implementation demonstrates how to use xgorm.WithDB(ctx, tx) to maintain
// transactional integrity across multiple table updates.
func _User_AddCreditCard_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(UserCreditCardReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).AddCreditCard(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_AddCreditCard_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).AddCreditCard(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// User remove a credit card
func _User_RemoveCreditCard_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(UserCreditCardReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).RemoveCreditCard(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_RemoveCreditCard_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).RemoveCreditCard(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// Get user specify credit card info
func _User_GetCreditCard_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(UserCreditCardReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetCreditCard(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_GetCreditCard_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).GetCreditCard(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// Get all credit cards under user
func _User_SearchCreditCard_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(common.ReqWithName)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SearchCreditCard(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SearchCreditCard_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(UserServer).SearchCreditCard(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// UserAmqpServiceDesc is the xamqp1.ServiceDesc for User service.
// It's only intended for direct use with xamqp1.AddHandler,
// and not to be introspected or modified (even as a copy)
//
// User example
// User service handles lifecycle management and data retrieval for User entities.
// It integrates with the Asjard Store layer to provide transparent caching
// and high-concurrency protection (Singleflight).
var UserAmqpServiceDesc = xamqp1.ServiceDesc{
	ServiceName: "api.v1.example.docs.User",
	HandlerType: (*UserServer)(nil),
	Methods:     []xamqp1.MethodDesc{},
}
