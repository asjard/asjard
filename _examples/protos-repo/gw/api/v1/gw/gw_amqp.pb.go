// Code generated by protoc-gen-go-amqp. DO NOT EDIT.
// versions:
// - protoc-gen-go-amqp v1.0.0
// - protoc             v5.27.0
// source: protos-repo/gw/api/v1/gw.proto

package gw

import (
	context "context"
	bootstrap "github.com/asjard/asjard/core/bootstrap"
	server "github.com/asjard/asjard/core/server"
	xamqp1 "github.com/asjard/asjard/pkg/server/xamqp"
	xamqp "github.com/asjard/asjard/pkg/stores/xamqp"
	amqp "github.com/streadway/amqp"
	proto "google.golang.org/protobuf/proto"
	sync "sync"
)

type GwAmqpClientOptions struct {
	clientName string
}
type GwAmqpClientOption func(opts *GwAmqpClientOptions)

func GwAmqpClientWithClient(clientName string) GwAmqpClientOption {
	return func(opts *GwAmqpClientOptions) {
		if clientName != "" {
			opts.clientName = clientName
		}
	}
}

type GwAmqpClient struct {
	*xamqp.ClientConn
	options *GwAmqpClientOptions
}

var (
	gwAmqpClient     *GwAmqpClient
	gwAmqpClientOnce sync.Once
)

func NewGwAmqpClient(opts ...GwAmqpClientOption) *GwAmqpClient {
	gwAmqpClientOnce.Do(func() {
		options := &GwAmqpClientOptions{
			clientName: "default",
		}
		for _, opt := range opts {
			opt(options)
		}
		gwAmqpClient = &GwAmqpClient{
			options: options,
		}
		bootstrap.AddBootstrap(gwAmqpClient)
	})
	return gwAmqpClient
}
func (c *GwAmqpClient) Start() error {
	conn, err := xamqp.Client(xamqp.WithClientName(c.options.clientName))
	if err != nil {
		return err
	}
	c.ClientConn = conn
	ch, err := conn.Channel()
	if err != nil {
		return err
	}
	defer ch.Close()
	for _, method := range GwAmqpServiceDesc.Methods {
		if method.Queue != "" {
			if _, err := ch.QueueDeclare(method.Queue, method.Durable, method.AutoDelete, method.Exclusive, method.NoWait, method.Table); err != nil {
				return err
			}
		}
		if method.Exchange != "" {
			if err := ch.ExchangeDeclare(method.Exchange, method.Kind, method.Durable, method.AutoDelete, method.Internal, method.NoWait, method.Table); err != nil {
				return err
			}
			if method.Queue != "" {
				if err := ch.QueueBind(method.Queue, method.Route, method.Exchange, method.NoWait, method.Table); err != nil {
					return err
				}
			}
		}
	}
	return nil
}
func (c *GwAmqpClient) Stop() {}
func (c *GwAmqpClient) GetChannel() (*amqp.Channel, error) {
	return c.ClientConn.Channel()
}

// 获取服务的所有实例
func (c *GwAmqpClient) GetServiceInstances(ctx context.Context, in *ServiceInstancesReq, opts ...xamqp1.PublishOption) error {
	options := &xamqp1.PublishOptions{}
	for _, opt := range opts {
		opt(options)
	}
	payload, err := proto.Marshal(in)
	if err != nil {
		return err
	}
	ch, err := c.GetChannel()
	if err != nil {
		return err
	}
	defer ch.Close()
	return ch.Publish(options.Exchange, options.Key, options.Mandatory, options.Immediate, amqp.Publishing{
		ContentType: "application/protobuf",
		Body:        payload,
	})
}

// 获取服务的所有实例
func _Gw_GetServiceInstances_AmqpHandler(ctx *xamqp1.Context, srv any, interceptor server.UnaryServerInterceptor) (any, error) {
	in := new(ServiceInstancesReq)
	if err := proto.Unmarshal(ctx.Body(), in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GwServer).GetServiceInstances(ctx, in)
	}
	info := &server.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gw_GetServiceInstances_FullMethodName,
		Protocol:   xamqp1.Protocol,
	}
	handler := func(ctx context.Context, req any) (any, error) {
		return srv.(GwServer).GetServiceInstances(ctx, in)
	}
	return interceptor(ctx, in, info, handler)
}

// GwAmqpServiceDesc is the xamqp1.ServiceDesc for Gw service.
// It's only intended for direct use with xamqp1.AddHandler,
// and not to be introspected or modified (even as a copy)
var GwAmqpServiceDesc = xamqp1.ServiceDesc{
	ServiceName: "api.v1.gw.Gw",
	HandlerType: (*GwServer)(nil),
	Methods:     []xamqp1.MethodDesc{},
}
