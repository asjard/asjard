/*
Package grpc provides the gRPC implementation of the server interface.
It allows the application to expose services via the high-performance gRPC protocol.
*/
package grpc

import (
	"context"
	"errors"
	"fmt"
	"net"
	"path/filepath"

	"github.com/asjard/asjard/core/config"
	"github.com/asjard/asjard/core/constant"
	"github.com/asjard/asjard/core/logger"
	"github.com/asjard/asjard/core/server"
	"github.com/asjard/asjard/utils"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/keepalive"
)

const (
	// Protocol defines the unique name for this server implementation.
	Protocol = "grpc"
)

// GrpcServer encapsulates the underlying gRPC server and its configuration.
type GrpcServer struct {
	server *grpc.Server
	conf   Config
}

// ServiceDesc is an alias for the standard gRPC service description.
type ServiceDesc = grpc.ServiceDesc

// Handler defines the interface that business services must implement
// to be registered with the GrpcServer.
type Handler interface {
	// GrpcServiceDesc returns the gRPC metadata required for registration.
	GrpcServiceDesc() *ServiceDesc
}

// Ensure GrpcServer satisfies the core server.Server interface.
var _ server.Server = &GrpcServer{}

func init() {
	// Automatically register this server type into the framework's server manager.
	server.AddServer(Protocol, New)
}

// MustNew initializes a gRPC server with the provided configuration and options.
func MustNew(conf Config, options *server.ServerOptions) (server.Server, error) {
	var opts []grpc.ServerOption

	// 1. Configure TLS Credentials if certificate and key files are provided.
	if conf.CertFile != "" && conf.KeyFile != "" {
		creds, err := credentials.NewServerTLSFromFile(conf.CertFile, conf.KeyFile)
		if err != nil {
			return nil, err
		}
		opts = append(opts, grpc.Creds(creds))
	}

	// 2. Apply Keepalive parameters to manage connection health and lifecycle.
	opts = append(opts, grpc.KeepaliveParams(keepalive.ServerParameters{
		MaxConnectionIdle: conf.Options.KeepaliveParams.MaxConnectionIdle.Duration,
		Time:              conf.Options.KeepaliveParams.Time.Duration,
		Timeout:           conf.Options.KeepaliveParams.Timeout.Duration,
	}))

	// 3. Register a Unary Interceptor to wrap gRPC calls with framework-level logic.
	opts = append(opts, grpc.ChainUnaryInterceptor(func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) {
		if options.Interceptor != nil {
			// Adapt framework's generic interceptor to the gRPC specific handler.
			return options.Interceptor(ctx, req, &server.UnaryServerInfo{
				Server:     info.Server,
				FullMethod: info.FullMethod,
				Protocol:   Protocol,
			}, func(ctx context.Context, in any) (any, error) {
				return handler(ctx, in)
			})
		}
		return handler(ctx, req)
	}))

	return &GrpcServer{
		server: grpc.NewServer(opts...),
		conf:   conf,
	}, nil
}

// New is the factory function called by the framework to create a gRPC server.
func New(options *server.ServerOptions) (server.Server, error) {
	conf := defaultConfig()
	// Load configuration from the global config system (e.g., yaml/nacos).
	if err := config.GetWithUnmarshal(constant.ConfigServerGrpcPrefix, &conf); err != nil {
		return nil, err
	}

	// Resolve absolute paths for security certificates.
	if conf.KeyFile != "" {
		conf.KeyFile = filepath.Join(utils.GetCertDir(), conf.KeyFile)
	}
	if conf.CertFile != "" {
		conf.CertFile = filepath.Join(utils.GetCertDir(), conf.CertFile)
	}

	return MustNew(conf, options)
}

// AddHandler registers a gRPC service implementation (generated by protoc) into the server.
func (s *GrpcServer) AddHandler(handler any) error {
	h, ok := handler.(Handler)
	if !ok {
		return fmt.Errorf("invalid handler %T, must implement *grpc.ServiceDesc", handler)
	}
	s.server.RegisterService(h.GrpcServiceDesc(), handler)
	return nil
}

// Start creates a TCP listener and begins serving requests in a background goroutine.
func (s *GrpcServer) Start(startErr chan error) error {
	if s.conf.Addresses.Listen == "" {
		return errors.New("config servers.grpc.addresses.listen not found")
	}
	listen, err := net.Listen("tcp", s.conf.Addresses.Listen)
	if err != nil {
		return err
	}

	go func() {
		// Serve will block until the server is stopped or an error occurs.
		if err := s.server.Serve(listen); err != nil {
			startErr <- err
		}
	}()

	logger.Debug("start grpc server", "address", s.conf.Addresses.Listen)
	return nil
}

// Stop performs a graceful shutdown, allowing active RPCs to finish before closing.
func (s *GrpcServer) Stop() {
	if s.server != nil {
		s.server.GracefulStop()
	}
}

// Protocol returns "grpc".
func (s *GrpcServer) Protocol() string {
	return Protocol
}

// Enabled checks if the gRPC server is active according to configuration.
func (s *GrpcServer) Enabled() bool {
	return s.conf.Enabled
}

// ListenAddresses returns the configured network addresses for this server.
func (s *GrpcServer) ListenAddresses() server.AddressConfig {
	return s.conf.Addresses
}
