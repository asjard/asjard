package interceptors

import (
	"context"

	"github.com/asjard/asjard/core/logger"
	"github.com/asjard/asjard/core/server"
	"github.com/asjard/asjard/pkg/protobuf/validatepb"
)

const (
	// ValidateInterceptorName is the unique identifier for this interceptor.
	ValidateInterceptorName = "validate"
)

func init() {
	// Register the validation interceptor globally.
	// It will be applied to both gRPC and REST requests.
	server.AddInterceptor(ValidateInterceptorName, NewValidateInterceptor)
}

// Validate is the interceptor responsible for checking request data integrity.
type Validate struct{}

// Name returns the interceptor's unique name.
func (r *Validate) Name() string {
	return ValidateInterceptorName
}

// NewValidateInterceptor initializes the validation component.
func NewValidateInterceptor() (server.ServerInterceptor, error) {
	return &Validate{}, nil
}

// Interceptor returns the middleware function that executes the validation logic.
func (r *Validate) Interceptor() server.UnaryServerInterceptor {
	return func(ctx context.Context, req any, info *server.UnaryServerInfo, handler server.UnaryHandler) (resp any, err error) {
		logger.L(ctx).Debug("start server interceptor", "interceptor", r.Name(), "full_method", info.FullMethod, "protocol", info.Protocol)
		// 1. Check if the request object implements the Validater interface.
		// This interface is usually generated by a protoc plugin (like protoc-gen-validate).
		if v, ok := req.(validatepb.Validater); ok {
			// 2. Perform the validation.
			// The first parameter is usually a field path prefix (empty for root).
			// The second parameter provides context on which method is being called.
			if err := v.IsValid("", info.FullMethod); err != nil {
				// 3. If validation fails, return the error immediately.
				// This prevents the business logic from executing with invalid data.
				return nil, err
			}
		}

		// 4. If validation passes (or if the object doesn't support validation),
		// proceed to the next handler.
		return handler(ctx, req)
	}
}
